#!/usr/bin/env python3

import datetime
from typing import List, Tuple

PUBLIC_CFG_ENV_VARS = (
    ('GIT_DIR', '${PUBLIC_CONFIG_GIT_DIR}'),
    ('GIT_WORK_TREE', '${HOME}'),
)
PRIVATE_CFG_ENV_VARS = (
    ('GIT_DIR', '${PRIVATE_CONFIG_GIT_DIR}'),
    ('GIT_WORK_TREE', '${HOME}'),
)

GIT_ALIASES = {
    '': 'git',
    'a': 'git add',
    'ap': 'git-add-and-push',
    'af': 'git-add-fzf',
    'au': 'git add --update',
    'b': 'git branch',
    'ba': 'git branch --all',
    'c': 'git commit',
    'cp': 'git commit && git push',
    # 'gcam':'git commit --amend --message',
    'cl': 'git clone',
    'cm': 'git commit --message',
    'co': 'git checkout',
    'cof': 'git-checkout-commit-fzf',
    'cr': 'git-cd-root',
    'd': 'git diff',
    'dh': 'git diff HEAD',
    'dd': 'git diff .',
    'ds': 'gd --staged',
    'dn': 'gd --name-only',
    'dt': 'git difftool',
    'dts': 'gdt --staged',
    'dtn': 'gdt --name-only',
    'g': 'git grep',
    'gl': 'git grep --files-with-matches',
    'im': 'nvim -c ":MagitOnly"',
    'l': 'git log --pretty=myshort',
    'la': 'git log --pretty=myshort --all --graph',
    'lp': 'git log --pretty=mymedium --patch',
    'ls': 'git log --pretty=mymedium --stat',
    # 'lss':'git log --oneline --decorate --graph',
    # 'lg':'git log --oneline --decorate --graph --branches',
    'op': 'git open',
    'pb': 'git-push-blind',
    'pl': 'git pull',
    'prs': 'git-fetch-prs',
    'pu': 'git push',
    'rf': 'git-reset-fzf',
    'rmt': 'git remote',
    's': 'git status',
    'ss': 'git status --short',
}


# Implements simplistic heuristics for figuring out if a command is "complex",
# which means in this context that it's composed of multiple commands with
# and/or relations, or simple command chaining.
def _is_complex_command(cmd: str) -> bool:
    return '||' in cmd or '&&' in cmd or ';' in cmd


def _get_command_for_env(env_vars: List[Tuple[str, str]], cmd: str) -> str:
    var_setting_cmd = ' '.join(f'{name}="{value}"' for name, value in env_vars)
    if not _is_complex_command(cmd):
        return f'{var_setting_cmd} {cmd}'
    return f'(export {var_setting_cmd}; {cmd})'


def main():
    print('# Autogenerated git aliases {{{ #')
    print('# Generated by generate_git_aliases.py on '
          f'{datetime.datetime.utcnow().strftime("%Y-%m-%d %T")} UTC')
    for alias, cmd in GIT_ALIASES.items():
        print(f"alias 'g{alias}'='{cmd}'")
        public_cfg_cmd = _get_command_for_env(PUBLIC_CFG_ENV_VARS, cmd)
        private_cfg_cmd = _get_command_for_env(PRIVATE_CFG_ENV_VARS, cmd)
        print(f"alias 'gf{alias}'='{public_cfg_cmd}'")
        print(f"alias 'gfr{alias}'='{private_cfg_cmd}'")
    print('# End of generated git aliases')
    print('# }}} Autogenerated git aliases #')


if __name__ == '__main__':
    main()
