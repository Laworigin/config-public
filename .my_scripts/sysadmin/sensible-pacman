#!/usr/bin/env bash

# See https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/
set -o errexit -o errtrace -o nounset -o pipefail

readonly PACMAN_LOG_FILE='/var/log/pacman.log'

_command_exists() {
  command -v -- "$1" &> /dev/null
}

# https://github.com/dylanaraps/pure-bash-bible#strip-pattern-from-end-of-string
_rstrip() {
  # Usage: rstrip "string" "pattern"
  printf '%s\n' "${1%%$2}"
}

_num_lines() {
  if _command_exists wc; then
    _rstrip "$(wc -l "$1")" ' *'
    return
  fi
  # TODO: fall back to counting lines based on grep
  # if _command_exists grep; then
  #   return
  # fi
}

_warning() {
  local warning normal
  # Yellow color
  warning="$(tput setaf 3 2> /dev/null)" || true
  normal="$(tput sgr0 2> /dev/null)" || true
  printf >&2 'sensible-pacman: warning: %s\n' "${warning}${*}${normal}"
}

# Print a message in a format similar to pacman and yay
_message() {
  local bold='' color='' normal=''
  if [[ -t 1 ]]; then
    color="\033[1;36m"
    bold="$(tput bold 2> /dev/null)" || true
    normal="$(tput sgr0 2> /dev/null)" || true
  fi
  echo -en "${color}"
  printf ':: %s\n' "${normal}${bold}${*}${normal}"
}

_print_from_line() {
  local file="$1"
  local n="$2"
  if _command_exists tail; then
    tail "-n+${n}" -- "${file}"
    return
  fi
  if _command_exists sed; then
    sed -n "${n},999999999p" -- "${file}"
    return
  fi
  return 1
}

# Heuristic for figuring out if pacman needs to run with sudo.
_does_pacman_need_sudo() {
  if ((EUID == 0)); then
    return 1
  fi
  # Bash's getopts doesn't support long options, so we start by parsing them
  # manually.
  local -A long_options
  local keep_parsing=1
  local args_without_long_options=()
  for arg in "$@"; do
    # Skip anything but long options.
    if [[ "${arg}" != --* ]]; then
      args_without_long_options+=("${arg}")
      continue
    fi
    # `--sync` and `--database` sometimes require sudo, depending on the other
    # options. The other operations always require or do not require sudo, so if
    # we observe them we can return immediately.
    if [[ "${arg}" =~ --(upgrade|remove|refresh) ]]; then
      return 0
    fi
    if [[ "${arg}" =~ --(query|deptest|version|help) ]]; then
      return 1
    fi
    if [[ "${arg}" == -- ]]; then
      keep_parsing=0
      break
    fi
    # Remove the leading --.
    long_options["${arg##--}"]=1
  done
  local -A short_options
  if ((keep_parsing)); then
    local opt
    # The prefix colon to getopts is to ignore errors (unknown args).
    while getopts ':DQRSTUFVhilgsky' opt "${args_without_long_options[@]}"; do
      case ${opt} in
        U | R | y) return 0 ;;
        Q | T | V | h) return 1 ;;
        *) short_options["${opt}"]=1 ;;
      esac
    done
  fi
  if ((long_options[database] || short_options[D])); then
    if ((long_options[check] || short_options[k])) ||
      ((long_options[asexplicit])); then
      return 1
    fi
    return 0
  fi
  if ((long_options[sync] || short_options[S])); then
    if ((long_options[groups] || short_options[g])) ||
      ((long_options[info] || short_options[i])) ||
      ((long_options[list] || short_options[l])); then
      return 1
    fi
    return 0
  fi
  return 1
}

main() {
  local cmd=()
  if _does_pacman_need_sudo "$@"; then
    cmd+=(sudo)
  fi
  cmd+=(pacman "$@")
  # TODO: check news, see:
  # https://github.com/infokiller/pacnanny
  local n
  n="$(_num_lines "${PACMAN_LOG_FILE}")"
  local s=0
  "${cmd[@]}" || s=$?
  local log
  if log="$(_print_from_line "${PACMAN_LOG_FILE}" "$((n + 1))")" && [[ -n "${log}" ]]; then
    # grep -E 'warning|pacsave|pacnew' <<< "${log}" || true
    local warnings=()
    while IFS='' read -r line; do
      if [[ "${line}" =~ .*(warning|pacsave|pacnew).* ]]; then
        warnings+=("${line}")
      fi
    done <<< "${log}"
    if ((${#warnings[@]})); then
      _message 'Last warnings:'
    fi
    for line in "${warnings[@]}"; do
      printf '%s\n' "${line}"
    done
  else
    _warning 'failed printing logs'
  fi
  return $s
}

main "$@"
